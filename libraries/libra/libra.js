// Generated by CoffeeScript 2.5.1
(function() {
  //# libra #######################################################################
  var all, clear, getType, global, isArray, isBool, isBoolean, isFunc, isFunction, isNull, isNumber, isObject, isString, isType, isUndefined, isVoid, libra, log, pack, scope, table, use, warn,
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  log = console.log;

  clear = console.clear;

  table = console.table;

  warn = console.warn;

  all = function*(arg) {
    while (true) {
      yield arg;
    }
  };

  use = function(object) {
    return function(dict) {
      var key, results, val;
      results = [];
      for (key in dict) {
        if (!hasProp.call(dict, key)) continue;
        val = dict[key];
        results.push(object[key] = val);
      }
      return results;
    };
  };

  global = function(arg) {
    var key, results, val;
    results = [];
    for (key in arg) {
      if (!hasProp.call(arg, key)) continue;
      val = arg[key];
      if (window[key] != null) {
        warn('[global]: overwriting ' + key);
      }
      results.push(window[key] = val);
    }
    return results;
  };

  scope = function() {
    return arguments[0]();
  };

  libra = {};

  pack = use(libra);

  pack({all, use, global, scope});

  //#######################################
  getType = (function() {
    var toString;
    toString = {}.toString;
    return function(arg) {
      return toString.call(arg).slice(8, -1);
    };
  })();

  isType = function(thing, type) {
    return (getType(thing)) === type;
  };

  isString = function(arg) {
    return isType(arg, 'String');
  };

  isNumber = function(arg) {
    return (isType(arg, 'Number')) && (!isNaN(arg));
  };

  isBoolean = function(arg) {
    return isType(arg, 'Boolean');
  };

  isArray = function(arg) {
    return isType(arg, 'Array');
  };

  isObject = function(arg) {
    return isType(arg, 'Object');
  };

  isFunction = function(arg) {
    return isType(arg, 'Function');
  };

  isUndefined = function(arg) {
    return isType(arg, 'Undefined');
  };

  isNull = function(arg) {
    return isType(arg, 'Null');
  };

  isBool = isBoolean;

  isVoid = isUndefined;

  isFunc = isFunction;

  pack({getType, isType, isString, isNumber, isBoolean, isArray, isObject, isFunction, isUndefined, isNull, isBool, isVoid, isFunc});

  //#######################################
  scope(function() {
    var $, $$, getLines, isEven, isOdd, libraTest, max, min, sleep, zFill;
    max = Math.max;
    min = Math.min;
    isEven = function(n) {
      return n % 2 === 0;
    };
    isOdd = function(n) {
      return n % 2 === !0;
    };
    getLines = function(arg) {
      return arg.split(/\r?\n/);
    };
    zFill = function(n, m) {
      return `${n}`.padStart(m, '0');
    };
    sleep = function(ms) {
      return new Promise(function(resolve) {
        return setTimeout(resolve, ms);
      });
    };
    $ = function(selector) {
      return document.querySelector(selector);
    };
    $$ = function(selector) {
      return document.querySelectorAll(selector);
    };
    libraTest = {};
    return pack({log, table, clear, max, min, isEven, isOdd, getLines, zFill, sleep, $, $$, libraTest});
  });

  //#######################################
  scope(function() {
    var random, randomElement, randomFloat, randomInteger, shuffle;
    // shuffles array in place
    // uses fisher yates shuffle
    // https://bost.ocks.org/mike/shuffle/
    shuffle = function(array) {
      var i, m;
      m = array.length;
      // While there remain elements to shuffle…
      while (m) {
        // Pick a remaining element…
        i = Math.floor(random() * m--);
        // And swap it with the current element.
        [array[m], array[i]] = [array[i], array[m]];
      }
      //t = array[m]
      //array[m] = array[i]
      //array[i] = t
      return array;
    };
    pack({shuffle});
    //# Returns a random integer between min and max.
    //# Both upper and lower bound are inclusive.
    //# Based on code from mdn and personally tested.
    randomInteger = function(min, max) {
      var multiplier, randomNumber, result;
      min = Math.ceil(min);
      max = Math.floor(max);
      randomNumber = Math.random();
      multiplier = max - min + 1;
      result = randomNumber * multiplier + min;
      return Math.floor(result);
    };
    //# Returns a random float between min (inclusive)
    //# and max (exclusive). Based of code from mdn.
    randomFloat = function(min, max) {
      return Math.random() * (max - min) + min;
    };
    randomElement = function(array) {
      var lastIndex;
      lastIndex = array.length - 1;
      return array[randomInteger(0, lastIndex)];
    };
    random = function(a, b) {
      if (a === void 0) {
        return Math.random();
      }
      if (Array.isArray(a)) {
        return randomElement(a);
      }
      if (b === void 0) {
        return randomInteger(1, a);
      }
      return randomInteger(a, b);
    };
    random.int = randomInteger;
    random.float = randomFloat;
    random.element = randomElement;
    return pack({random});
  });

  //#######################################
  scope(function() {
    var $, attachHTML, createTag, html, loadHTML, parseNode, replaceHTML, replaceInnerHTML;
    ({$} = libra);
    html = function(html) {
      return window.onload = function() {
        return ($('body')).innerHTML = html;
      };
    };
    loadHTML = function(html) {
      return ($('body')).innerHTML = html;
    };
    replaceInnerHTML = function(node, html) {
      if (isString(node)) {
        node = $(node);
      }
      return node.innerHTML = html;
    };
    replaceHTML = function(node, html) {
      if (isString(node)) {
        node = $(node);
      }
      return node.outerHTML = html;
    };
    attachHTML = function(node, html) {
      if (isString(node)) {
        node = $(node);
      }
      return node.insertAdjacentHTML('beforeend', html);
    };
    createTag = function(tag) {
      return function(...args) {
        var key, obj, result, val;
        result = ['<', tag];
        if (args[0] && !isString(args[0])) {
          obj = args.shift();
          for (key in obj) {
            if (!hasProp.call(obj, key)) continue;
            val = obj[key];
            result.push(` ${key}=\"${val}\"`);
          }
        }
        result.push('>');
        result = result.concat(args);
        result.push(`</${tag}>`);
        return result.join('');
      };
    };
    //###
    parseNode = function(html) {
      return document.createRange().createContextualFragment(html);
    };
    html.elements = function() {
      return buildObject(html.elements.names, function(arg) {
        return createTag(arg);
      });
    };
    html.globalize = function(elements = html.elements.names) {
      var buildObject;
      ({buildObject} = libra);
      if (isString(elements)) {
        elements = elements.split(' ');
      }
      return global(buildObject(elements, function(arg) {
        return createTag(arg);
      }));
    };
    html.elements.names = 'base link meta style address article aside footer header h1 h2 h3 h4 h5 h6 hgroup main nav section blockquote dd div dl dt figcaption figure hr li ol p pre ul a abbr b bdi bdo br cite code data dfn em i kbd mark q rb rp rt rtc ruby s samp small span strong sub sup time u var wbr area audio img map track video embed iframe object param picture portal source svg math canvas script del ins caption col colgroup table tbody td tfoot th thead tr button datalist fieldset form input label legend meter optgroup option output progress select textarea details dialog menu summary slot template'.split(' ');
    return pack({html, loadHTML, replaceInnerHTML, replaceHTML, attachHTML, createTag, parseNode});
  });

  //#######################################
  scope(function() {
    var vault, vaultClear, vaultRemove, vaultRetrieve, vaultStore;
    vaultStore = function(key, value) {
      return localStorage.setItem(key, JSON.stringify(value));
    };
    vaultRetrieve = function(key) {
      return JSON.parse(localStorage.getItem(key));
    };
    vaultRemove = function(key) {
      return localStorage.removeItem(key);
    };
    vaultClear = function() {
      return localStorage.clear();
    };
    vault = function(key, value) {
      if (arguments.length === 0) {
        return localStorage;
      }
      if (arguments.length === 1) {
        return vaultRetrieve(key);
      }
      if (arguments.length === 2) {
        return vaultStore(key, value);
      }
    };
    vault.store = vaultStore;
    vault.retrieve = vaultRetrieve;
    vault.set = vaultStore;
    vault.get = vaultRetrieve;
    vault.remove = vaultRemove;
    vault.remove = vaultRemove;
    vault.clear = vaultClear;
    vault.empty = vaultClear;
    return pack({vault});
  });

  //#######################################
  scope(function() {
    var buildObject, repeat;
    // repeat 5 -> ....
    repeat = function(n, f) {
      var i, results;
      i = 0;
      results = [];
      while (i++ < n) {
        results.push(f(i));
      }
      return results;
    };
    buildObject = function(keys, func) {
      var j, key, len, res;
      res = {};
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        res[key] = func(key);
      }
      return res;
    };
    return pack({repeat, buildObject});
  });

  //#######################################
  scope(function() {
    var TCO, count, count2, goto, libraTest, tco;
    TCO = Symbol('TCO');
    goto = function() {
      return [TCO, ...arguments];
    };
    tco = function(res) {
      while (true) {
        if ((Array.isArray(res)) && (res[0] === TCO)) {
          res.shift();
          res = res.shift()(...res);
        } else {
          return res;
        }
      }
    };
    pack({TCO, goto, tco});
    ({libraTest} = libra);
    count = function(n) {
      if (n > 1000000) {
        return n;
      }
      return goto(count, ++n);
    };
    count2 = function(n) {
      if (n > 1000000) {
        return n;
      }
      return count2(++n);
    };
    libraTest.countWithTCO = function() {
      return tco(count(0));
    };
    return libraTest.countWithoutTCO = function() {
      return count2(0);
    };
  });

  //#######################################
  scope(function() {
    var $, buildChunks, countSpaces, css, isOnlyWhitespace, preprocessLine, processBlock, processLine, processPart, translateLine;
    ({$} = libra);
    css = function(argA, argB) {
      //log argA, argB
      if ((isString(argA)) && (isUndefined(argB))) {
        return css.load(argA);
      }
      if ((isObject(argA)) && (isUndefined(argB))) {
        return css.bind(argA);
      }
      return 'invalid css call';
    };
    css.preprocessors = {};
    css.stylesheets = {};
    css.bindings = {};
    css.lineSep = '\n';
    css.blockSep = '\n\n';
    css.remove = function(name) {
      return css.stylesheets[name].remove();
    };
    css.get = function(name) {
      return css.stylesheets[name];
    };
    css.getCSS = function(name) {
      return css.stylesheets[name].innerHTML;
    };
    css.disable = function(name) {
      return css.stylesheets[name].disabled = true;
    };
    css.enable = function(name) {
      return css.stylesheets[name].disabled = false;
    };
    css.load = function(lssCode) {
      var cssCode, name, node;
      [name, cssCode] = css.parse(lssCode);
      node = document.createElement('style');
      node.innerHTML = cssCode;
      css.stylesheets[name] = node;
      ($('head')).appendChild(node);
      return name;
    };
    css.preload = function(lssCode) { // maybe
      var name;
      name = css.load(lssCode);
      css.disable(name);
      return name;
    };
    css.bind = function(bindings) {
      var cssCode, cssLines, key, node, ref, val;
      for (key in bindings) {
        val = bindings[key];
        css.bindings[key] = val;
      }
      cssLines = ['/* bindings.libra.css */', '', ':root {'];
      ref = css.bindings;
      for (key in ref) {
        val = ref[key];
        cssLines.push(`    --${key}: ${val};`);
      }
      cssLines.push('}');
      cssCode = cssLines.join('\n');
      if (css.stylesheets.bindings == null) {
        node = document.createElement('style');
        ($('head')).appendChild(node);
        css.stylesheets.bindings = node;
      }
      css.stylesheets.bindings.innerHTML = cssCode;
    };
    css.parse = function(lssCode) {
      var animations, block, blocks, cssBlocks, cssCode, cssLines, getLines, j, len, name, states, styleSheet, stylesheetName;
      ({getLines} = libra);
      cssLines = getLines(lssCode).map(function(line) {
        return line.trimEnd();
      }).filter(function(line) {
        return line !== '';
      });
      blocks = buildChunks(cssLines, 2);
      blocks = blocks.map(processBlock);
      stylesheetName = 'default';
      animations = {};
      cssBlocks = [];
      for (j = 0, len = blocks.length; j < len; j++) {
        block = blocks[j];
        switch (block[0][0]) {
          case 'NAME':
            styleSheet = block[0][1];
            break;
          case 'SELECT':
          case 'COMMENT':
            cssBlocks.push(block[1]);
            break;
          case 'KEYFRAME':
            name = block[0][1];
            if (animations[name] == null) {
              animations[name] = [];
            }
            animations[name].push(block[1]);
            break;
          default:
            log(block);
        }
      }
//log cssBlocks, animations
      for (name in animations) {
        states = animations[name];
        cssBlocks.push([`@keyframes ${name} {`, ...states, "}"].join(css.lineSep));
      }
      cssBlocks.unshift(`/* ${stylesheetName}.libra.css */`);
      cssCode = cssBlocks.join(css.blockSep).replaceAll(' (', ' calc(').replaceAll(/\$([a-zA-Z0-9-_]+):/g, '--$1:').replaceAll(/\$([a-zA-Z0-9-_]+)/g, 'var(--$1)');
      return [stylesheetName, cssCode + '\n'];
    };
    buildChunks = function(lines, levels = 1) {
      var baseIndent, chunk, chunks, j, len, line, min;
      ({min} = libra);
      if (lines.length === 0) {
        return [];
      }
      baseIndent = min(...((function() {
        var j, len, results;
        results = [];
        for (j = 0, len = lines.length; j < len; j++) {
          line = lines[j];
          results.push(countSpaces(line));
        }
        return results;
      })()));
      if ((countSpaces(lines[0])) !== baseIndent) {
        throw 'IndentationError: first line not part of any chunk';
      }
      chunks = [];
      for (j = 0, len = lines.length; j < len; j++) {
        line = lines[j];
        if ((countSpaces(line)) === baseIndent) {
          chunks.push([]);
        }
        chunks[chunks.length - 1].push(line);
      }
      if (levels === 1) {
        return chunks;
      }
      return (function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = chunks.length; k < len1; k++) {
          chunk = chunks[k];
          results.push([[chunk[0]]].concat(buildChunks(chunk.slice(1), levels - 1)));
        }
        return results;
      })();
    };
    countSpaces = function(line) {
      var i;
      i = 0;
      while (line[i] === ' ') {
        i++;
      }
      return i;
    };
    processBlock = function(block) {
      var animation, head, index, line, percentage, ref, tail;
      if (block[0][0].startsWith('#')) {
        return [['#']];
      }
      line = block[0][0];
      index = line.indexOf(' ');
      if (index === -1) {
        head = line;
        tail = '';
      } else {
        head = line.slice(0, index);
        tail = line.slice(index).trim();
      }
      //log head
      if (head === 'NAME') {
        return [[head, tail], ' '];
      }
      if (head === 'COMMENT') {
        block[0] = '/* ' + tail.trim();
        block.push('*/');
        return [[head], block.join(css.lineSep).replaceAll(/\n[ ]*/g, '\n')];
      }
      block = block.map(processLine).filter(isOnlyWhitespace);
      if (head === 'SELECT') {
        block[0] = `${tail} {`;
        block.push("}");
        return [[head], block.join(css.lineSep)];
      }
      if (head === 'KEYFRAME') {
        ref = tail.split(' '), [animation] = ref, [percentage] = slice.call(ref, -1);
        block[0] = `${percentage} {`;
        block.push("}");
        return [[head, animation], block.join(css.lineSep)];
      }
      throw `LSS Error: block cannot start with '${head}'`;
    };
    isOnlyWhitespace = function(arg) {
      return arg.trim().length !== 0;
    };
    processLine = function(line) {
      var ref;
      line = line.map(processPart).join(' ');
      if ((ref = line.split(' ', 1)[0]) === 'SELECT' || ref === 'KEYFRAME' || ref === 'NAME') {
        return line;
      }
      if (line.startsWith('#')) {
        return ' ';
      }
      //line = line.replaceAll('#', '').trim()
      //return "/ * #{line} * /"
      return (preprocessLine(line)).split('\n').map(translateLine).join(css.lineSep);
    };
    preprocessLine = function(line) {
      var index, preprocFunc;
      // helper for css.parse

      // get first word of line
      index = line.indexOf(' ');
      if (index === -1) {
        index = line.length;
      }
      // if first line has preprocessor registered, use it.
      // otherwise, return line unchanged.
      preprocFunc = css.preprocessors[line.substring(0, index)];
      if (isFunction(preprocFunc)) {
        return preprocFunc(line);
      } else {
        return line;
      }
    };
    translateLine = function(line) {
      var head, index, tail;
      index = line.indexOf(' ');
      if (index === -1) {
        return line + ':;';
      }
      head = line.slice(0, index);
      tail = line.slice(index);
      return `${head}:${tail};`;
    };
    processPart = function(part) {
      return part.trim();
    };
    return pack({css});
  });

  //#######################################
  scope(function() {
    var css;
    ({css} = libra);
    return css.preprocessors.bg = function(arg) {
      return arg.replace('bg', 'background');
    };
  });

  //#######################################
  scope(function() {
    var bytesToHex, hexToBytes;
    bytesToHex = function(bytes) {
      if (isType(bytes, "ArrayBuffer")) {
        bytes = new Uint8Array(bytes);
      }
      if (isType(bytes, 'Uint8Array')) {
        bytes = Array.from(bytes);
      }
      return bytes.map(function(byte) {
        return byte.toString(16).padStart(2, '0');
      }).join('');
    };
    hexToBytes = function(hex) {
      var _, i, j, len, results;
      results = [];
      for (i = j = 0, len = hex.length; j < len; i = j += 2) {
        _ = hex[i];
        results.push(parseInt(hex.slice(i, +(i + 1) + 1 || 9e9), 16));
      }
      return results;
    };
    return pack({hexToBytes, bytesToHex});
  });

  //#######################################
  scope(function() {
    var algoParams, decrypt, digest, encrypt, exportKey, generateKey, importKey, keyGenParams, keyImportParams;
    algoParams = {
      aesCtr: function({counter} = {}) {
        if (counter) {
          counter = new Uint8Array(hexToBytes(counter));
        } else {
          counter = crypto.getRandomValues(new Uint8Array(16));
        }
        return {
          name: "AES-CTR",
          counter,
          length: 64
        };
      }
    };
    keyGenParams = {
      aesCtr: {
        name: "AES-CTR",
        length: 256
      }
    };
    keyImportParams = {
      aesCtr: {
        name: "AES-CTR"
      }
    };
    encrypt = async function(key, message, {algorithm, mode} = {}) {
      var counter, encryptedMessage, params;
      if (algorithm == null) {
        algorithm = 'aesCtr';
      }
      key = (await importKey(key, ['encrypt']));
      params = algoParams[algorithm]();
      if (mode === 'hex') {
        message = hexToBytes(message);
      }
      if (isString(message)) {
        message = (new TextEncoder()).encode(message);
      }
      if (isArray(message)) {
        message = new Uint8Array(message);
      }
      encryptedMessage = (await crypto.subtle.encrypt(params, key, message));
      counter = bytesToHex(params.counter);
      encryptedMessage = bytesToHex(encryptedMessage);
      return {counter, encryptedMessage};
    };
    decrypt = async function(key, data, {algorithm, mode} = {}) {
      var encryptedMessage, message, params;
      if (algorithm == null) {
        algorithm = 'aesCtr';
      }
      key = (await importKey(key, ['decrypt']));
      params = algoParams[algorithm](data);
      encryptedMessage = new Uint8Array(hexToBytes(data.encryptedMessage));
      message = (await crypto.subtle.decrypt(params, key, encryptedMessage));
      if (mode === 'hex') {
        return bytesToHex(message);
      }
      return (new TextDecoder()).decode(message);
    };
    generateKey = async function(algorithm = 'aesCtr') {
      var key, params;
      params = keyGenParams[algorithm];
      key = (await crypto.subtle.generateKey(params, true, ['encrypt']));
      return exportKey(key);
    };
    exportKey = async function(key) {
      var rawKey;
      rawKey = (await crypto.subtle.exportKey('raw', key));
      return bytesToHex(rawKey);
    };
    importKey = async function(key, usages, algorithm = 'aesCtr') {
      var params;
      key = new Uint8Array(hexToBytes(key));
      params = keyImportParams[algorithm];
      key = (await crypto.subtle.importKey('raw', key, params, true, usages));
      return key;
    };
    digest = async function(message, algorithm = 'sha256') {
      var digested;
      message = (new TextEncoder()).encode(message);
      algorithm = algorithm.replace('sha', 'SHA-');
      digested = (await crypto.subtle.digest(algorithm, message));
      return bytesToHex(digested);
    };
    window.testSecret = async function() {
      var decMsg, encMsg, key, msg;
      msg = 'test';
      key = (await generateKey());
      log(key);
      encMsg = (await encrypt(key, msg));
      log(encMsg);
      decMsg = (await decrypt(key, encMsg));
      log(decMsg);
      return msg === decMsg;
    };
    return pack({
      secret: {encrypt, decrypt, generateKey, digest}
    });
  });

  //# lock ########################################################################

  //#######################################
  scope(function() {
    var re, t, tokenize;
    re = /("|')((?:\\\1|(?:(?!\1).))*)\1|[\w\d-]*\(|\)|[$]?[\w\d-]+:?|[-+\/*%=,;|]+/g;
    tokenize = function(line) {
      var res, token;
      res = [];
      while (true) {
        token = re.exec(line);
        if (token == null) {
          break;
        }
        res.push(token[0]);
      }
      return res;
    };
    pack({tokenize});
    return t = `fullscreen
font bold 400px sans-serif
display grid
place-content center
textClip url('../../demo/canyon.jpg')
user-select none`;
  });

  // console.log(tokenize(t))

  // libra.repeat 20, -> log tokenize 'fullscreen'
  global(libra);

}).call(this);
